/*Created by Eli Muir (Synapse LLC)	http://www.synapse.com	http://wallofcool.synapse.comOriginally Created by Min Thu	http://www.flashmo.comAS3 References and Credits	http://blog.papervision3d.org/	http://theflashblog.com/?p=306	http://www.gotoandlearn.com/	http://www.onerutter.com/	http://labs.blitzagency.com/	http://vilebody.wordpress.com/2007/11/29/3d-papervision-plane-events/	http://www.nabble.com/Open-Source-3D-Wall-td17989860.html*/package org.synapse {	/* Synapse Classes */	import org.synapse.wallImage;	import org.synapse.ImageEvent;	import org.synapse.CameraWithSlerp;			/* Flash Classes */	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.display.Stage;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.external.ExternalInterface;	import flash.filters.GlowFilter;	import flash.text.TextField;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.ui.Mouse;	import flash.utils.Dictionary;	import flash.utils.Timer;	import fl.controls.List; 	import fl.controls.ProgressBar;	import fl.data.DataProvider; 			/* Tweening Classes */	import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.*;	import gs.TweenMax;	import gs.easing.Cubic;	import caurina.transitions.Tweener;	import caurina.transitions.properties.CurveModifiers;			/* RELFECTION CLASS */	import de.flamelab.display.Reflection;				/* PV3D Engine Clases */	import org.papervision3d.core.math.Quaternion;	import org.papervision3d.core.effects.*;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.cameras.*;	import org.papervision3d.events.*;	import org.papervision3d.objects.*;	import org.papervision3d.objects.primitives.*;	import org.papervision3d.materials.*;	import org.papervision3d.render.*;	import org.papervision3d.view.*;		[SWF(width="980", height="500", backgroundColor="#FFFFFF", frameRate="60")]		public class wallofcool extends Sprite{			/* Moving Vars */		public static var TWEEN_TIME:Number = 1;		public static var DISTANCE_FROM_PLANE:Number = 500;		//var cameraWithSlerp:CameraWithSlerp = new CameraWithSlerp();		private var cameraWithSlerp:Camera3D = new Camera3D();		private var startQuaternion:Quaternion = null;		private var endQuaternion:Quaternion = null;		private var currentQuaternion:Quaternion = null;				private var wallLocationX:Number = 0;		private var wallLocationY:Number = 0;		private var wallLocationZ:Number = 0;		private var moveStartPoint:Object = {x:wallLocationX,y:wallLocationY,z:wallLocationZ};		private var moveCurrPoint:Object = {x:wallLocationX,y:wallLocationY,z:wallLocationZ};		private var currWallObj:String = null;		private var _imageLoader:Loader;		private var _reflection:Reflection;					/* Object Container Vars */		private var totalXMLItems:Number = 0;					/* Counts total XML Items */		private var totalThumbnailCount:Number = 0;				/* Set holder for total thumbnail count from data source */		private var p_dict:Dictionary=new Dictionary();			/* Set Dictionary Obj */		private var imgHolders:Array = new Array();				/* Set array to hold images loaded from xml to Papervision API */		private var planeArray:Array = new Array(); 			/* Array to keep track of all thumbnai planes */					/* Common Vars */					public var allFlashVars:Object = LoaderInfo(stage.loaderInfo).parameters;	/* Pull in flashVar attributes */		private var startTimer:Date = new Date();										/* Keep track of time (used for debug of loading time, parsing time, etc) */		public var debugEnabled:Boolean = allFlashVars.debug || true;						/* Load debug setting from html object */		//if(!debugEnabled){debugEnabled= false;}else{debugEnabled = true;} 	/* Set debug default to false if not specificed in flashVars */					/* Papervision Environment Vars */		private var scene:Scene3D;												/* Create scene obj */		private var cam:Camera3D;												/* Create camera */		private var viewport:Viewport3D;										/* Create viewport */		private var renderer:BasicRenderEngine;									/* create render */		private var cameraTarget:DisplayObject3D = new DisplayObject3D();		/* create Camera Target */		private var cameraStart:DisplayObject3D = new DisplayObject3D();		/* create Camera Target */		private var myCursor:MovieClip;		private var mouseOverThumb:Boolean = false;					/* WALL ATTRIBUTES */		private var datafile:String = allFlashVars.datafile || "woc_data.xml"; 	/* Set Data Source URL */		private var wallStartLocation:Number = allFlashVars.startlocation || 0;	/* Set Wall Start Location */		private var wallCurve:Number = allFlashVars.curve || 0;						/* Set Wall Curviture */		//if(!wallCurve) { 	wallCurve = 0; }									/* Set default Wall curve if not specified */		private var wallType:String = allFlashVars.walltype || "flat";		//if(!wallType) { 	wallType = "flat";}				private var numOfThumbnailRows:Number = 3;							/* Set number of thumbnail rows */		private var wallLength:Number = 0;		private var wallHeight:Number = 0;		private var thmbWall:Sprite;		private var yPos:Number = 0;		private var angle:Number = 0;		private var wallMoveInterval:Timer = new Timer(1);		private var preloaderTimer:Timer = new Timer(5);					/* Thumbnail Settings */		private var thmbWidth:Number = 120;		private var thmbHeight:Number = 90;		private var thmbPadding:Number = 20;		private var thmbSize:Object = {width:thmbWidth, height:thmbHeight};		private var thmbSizePadding:Object = {width:(thmbWidth+thmbPadding),height:(thmbHeight+thmbPadding)};							/* Filter Effect Vars */		//private var dsf:DropShadowFilter = new DropShadowFilter(10, 45, 0x000000, 0.3, 6, 6, 1, 3);	/* Create Dropshadow Object for Wall thumbnails */		private var glow:GlowFilter = new GlowFilter(0x990000, 10, 15, 15);							/* Create Glow Effect for Wall Thumbnails */					/* Set data source for thumbnails */		private var widget_xml:XML;   							/* Create XML object to store values loaded from data source */		private var xmlloader:URLLoader = new URLLoader(); 		/* Create XML Loader object */		private var categoryloader:URLLoader = new URLLoader(); /* Create XML Loader object */		private var userlistloader:URLLoader = new URLLoader(); /* Create XML Loader object */				private var preloaderPct:Number = 0;		private var preloaderOp:String = "";		public function wallofcool() {						/* SETUP EVENT LISTENERS */			this.addEventListener(Event.ENTER_FRAME, startRender);	//Add base event listener to loop scene						setupPaperVision_wall();	//Setup Environment			loadXML();					//Load external XML Data file						/*			Dynamically Resize Stage Area							Resource: 				http://cobworks.ca/category/actionscript/				http://www.republicofcode.com/tutorials/flash/as3fluidresize/				*http://www.actionscript.org/forums/showthread.php3?t=158067			*/			this.stage.scaleMode = StageScaleMode.NO_SCALE;			this.stage.align = StageAlign.TOP_LEFT;			this.stage.addEventListener(Event.RESIZE, resizeListener);								resizeMe();							}						/**			*	Setup environment with papervision objects			*/		function setupPaperVision_wall():void {						viewport = new Viewport3D(0, 0, true, true);	/* Setup viewport Obj */				viewport.buttonMode=true; 						/* Enable 3d objects to be clickable */				viewport.interactive = true;					/* Enable mouse to interact with viewport obj */				scene = new Scene3D();							/* Create scene where our 3D objects will be displayed */				//cam = new Camera3D(60);						/* Create camera object with FOV 60 degrees */							/* default camera settings */				cameraWithSlerp.target = cameraTarget;	/* Assign camera target to target object */				cameraWithSlerp.z = -400;				cameraStart.copyTransform(cameraWithSlerp);	/* Copy the location, coords, settings of camera */									/* Create new renderer */				renderer = new BasicRenderEngine();				addChild(viewport);								setupBackground();								preloaderTimer.addEventListener(TimerEvent.TIMER, setPreloaderBar);				preloaderTimer.start();				//preloader.addEventListener(Event.ENTER_FRAME, setPreloaderBar);		}					/**			*	load XML file			*/		function loadXML():void {						debug("Loading XML: "+ datafile);										/* Send xml file loaded to debug window */			xmlloader.addEventListener(Event.COMPLETE, parseXMLData);				/* Listener when XML Load complate */			xmlloader.addEventListener(ProgressEvent.PROGRESS, onLoadXMLProgress);	/* Listener when XML loading progress */			xmlloader.addEventListener(IOErrorEvent.IO_ERROR, onLoadXMLError);		/* Listener when XML Load Errors */			xmlloader.load(new URLRequest(datafile));								/* Load XML into loader from data source */			preloader.visible = true;												/* Display preloader */							/* Remove any previous planes - used when reloading wall objects */			for (var i=1;i<planeArray.length;i++) {				scene.removeChild(planeArray[i]);			} 			imgHolders = new Array();	/* Create array to hold image parameters */		}					/**			*	Display percentage of XML file loaded			*/		function onLoadXMLProgress(e:ProgressEvent):void{			var perc:Number = Math.round((e.bytesLoaded/e.bytesTotal) * 100);	/* Get percent complete */			var percFriendly:String = perc+"%"									/* Create user friendly format */			preloader.progressIndicator.text = "Loading Data "+ percFriendly;	/* Display to user */			preloader.progressIndicator.autoSize;								/* autosize the text window */			preloader.pbar.scaleX = perc;										/* set scale of object to percentage number */							/* if percentage is 100 then remove progress listener */			if(perc >= 100){				e.currentTarget.removeEventListener(ProgressEvent.PROGRESS, onLoadXMLProgress);			}					}					/**			* Error handling for Loading XML data file			*/		function onLoadXMLError(evt:IOErrorEvent):void {			preloader.visible = true;							/* Make preloader movie visible */			preloader.pbar.visible = false;						/* Hide the preloader progress bar */			preloader.progressIndicator.text = "Error Loading";	/* update text to display loading error message */			//dispatchEvent(new Event(DOWNLOAD_ERROR));			debug("Error loading"+ evt.target);					/* Send loading error to debugger */		}							/**			*  Show progress while loading XML			*/		function setPreloaderBar(e:TimerEvent) {						var output:String;			preloader.x = this.stage.stageWidth/2;							/* Get progress of xml load */			switch (preloaderOp){				case "load":					output= "Loading"+"... "+ preloaderPct + "%";					preloader.visible = true;				break;								case "parse":					output = "Parsing"+"... "+ preloaderPct + "%";					preloader.visible = true;				break;								case "build":					output = "Building"+"... "+ preloaderPct + "%";					preloader.visible = true;				break;								case "complete":					preloaderTimer.stop();				break;								default:					output = "";				break;			}						if(output != null) {				preloader.pbar.scaleX = preloaderPct;				preloader.progressIndicator.text = String(output);				//preloadertest.text = output;				debug(output);				e.updateAfterEvent();			}		}					/**			* Parse the external XML file 			*/		function parseXMLData(e:Event):void {						try{									/* Set preloader parameters */				preloaderOp = "parse";				preloaderPct = 100;					var progressnow:Date = new Date();														/* Get current time to determine xml load time */				var xmlLoadTime:Number = ((progressnow.getTime() - startTimer.getTime()) / 1000 ) % 60;	/* calculate xml load time */				debug("XML Load Complete: "+xmlLoadTime);												/* send load time to debugger */								var mediaNs:Namespace = new Namespace("http://search.yahoo.com/mrss/");	/* Set namespace object for mediaRSS */				widget_xml = new XML(e.target.data);									/* Load xml data into  */				totalXMLItems = widget_xml..item.length();								/* Get total XML items */									/* Loop xml item and insert metadata into array */				for(var i=0; i<totalXMLItems; i++){										preloaderPct = Math.round((i/totalXMLItems * 100));	/* Calculate parse percentage based on current XML item */					var imgHolder:MovieClip = new MovieClip();			/* Create movieclip to hold image */					var imgLoader:Loader = new Loader(); 				/* Create Image Loader object */					//imgLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, progfin);											/*Set invidivual image array parameters */					imgHolder.addChild(imgLoader);	/* Add the imageLoader to the imageHolder */					imgHolder.name = "xmlImg_"+i;					imgHolder.myThumb = widget_xml..item[i].mediaNs::content.mediaNs::thumbnail.@url.toString();					imgHolder.hiRes = widget_xml..item[i].mediaNs::content.@url.toString();					imgHolder.myTitle = widget_xml..item[i].title.text();					//imgHolder.myAuthor = widget_xml..item[i].authorNS::creator.text();					imgHolder.myDesc = widget_xml..item[i].description.text();					imgHolder.myUrl = widget_xml..item[i].link.toString();					imgHolders.push(imgHolder);										}				var timenow:Date = new Date();				debug("XML Parsing Complete: "+ ((timenow.getTime() - progressnow.getTime()) / 1000 ) % 60);								buildWall();				/* end try */			}			catch(e:Error)			{				debug("Error: " + e);			/* send debug msg to firebug */				return;			}		}					/**			* Build the 3D wall from image holder array			*/		function buildWall() {						debug("buildWall");			startTimer = new Date();			totalThumbnailCount = imgHolders.length;	/* Count the total number of thumbnail nodes found */						var anglePer:Number = ((Math.PI*2) * numOfThumbnailRows) / totalThumbnailCount;			debug("TotalCount:"+ totalThumbnailCount +", AnglePer:"+ anglePer);					wallLength = (totalThumbnailCount/numOfThumbnailRows) * thmbSizePadding.width;	/* calculate wall length from total number of thumbnails */			wallHeight = numOfThumbnailRows * thmbSizePadding.height;						/* calculate wall height from total number of thumbnails*/						/* loop thru all thumbnails and add to 3d wall */			for(var x:uint=0; x<totalThumbnailCount; x++){								var rowCnt:Number = x % numOfThumbnailRows;				//Gets the current thumbnail row location				var colCnt:Number = Math.floor(x / numOfThumbnailRows);	//Gets the current column row location				//debug("Thumb:"+x+", row:"+rowCnt+", col:"+colCnt+","+numOfThumbnailRows+","+(rowCnt == (numOfThumbnailRows-1)));				var p:wallImage = new wallImage(imgHolders[x].myThumb, (rowCnt == (numOfThumbnailRows-1)));				p.name = "thmbImg_"+x; //set image name				p_dict[p.name] = p;									/* Complete Event Listener for WallImages  */				p.addEventListener(ImageEvent.THUMBIMAGE_LOADED, function(e:Event){ 						//var imageFade:Tween = new Tween(e.target.plane, 'alpha', Strong.easeOut, 0, 1, 0.5, true);						//debug("IMAGE LOADED ");				});									/* Event Listener for WallImages */ 				p.addEventListener(ImageEvent.THUMBIMAGE_PROGRESS, function(e:Event):void{ 						//debug("LOADING IMAGE");				});									/* Event Listener for Reflection */				p.addEventListener(ImageEvent.THUMBIMAGE_REFLECT, function(e:Event):void{ 						debug(e.target.name+":reflect");				});								/* Create MouseOver Listener */				p.addEventListener(ImageEvent.THUMBIMAGE_OVER, function(e:Event):void{						mouseOverThumb = true;				/* Set to true to hide custom cursor */						e.target._plane.filters = [glow];	/* Set glow filter for plane */				});									/* Create Mouse Out Listener */				p.addEventListener(ImageEvent.THUMBIMAGE_OUT, function(e:Event):void{						mouseOverThumb = false;						e.target._plane.filters = null; /* Remove glow filter */				});									/* Create Mouse Click Listener */				p.addEventListener(ImageEvent.THUMBIMAGE_CLICK, function(e:Event):void{						zoomTo(e.target);	/* Zoom to object clicked */				});								p.addEventListener(ImageEvent.ZOOM_OUT, function(e:Event):void{					debug("zoomOut"); 				});								var x_value:Number;				var y_value:Number;				var z_value:Number;													/* Determine the type of wall to layout images */				switch(wallType){												/* Basic horizontal wall */					case "flat":													/* Set the postion of each image */						var centerAdjust = wallHeight/numOfThumbnailRows; 			/* Make adjustment to vertically center wall */						x_value = colCnt * thmbSizePadding.width;					/* calculate X position */						y_value = -(rowCnt * thmbSizePadding.height)+centerAdjust; 	/* calculate Y position */						z_value = 0;												/* calculate Z position */						p.setPosition(x_value, y_value);							/* Set plane position */						break;												/* Basic vertical wall */					case "vertical-flat":												var vspacer:Number = 50;					/* provide vertical spacer for each image */						var zspacer:Number = 200;					/* provide z plane spacer  */						x_value = rowCnt * thmbSizePadding.height;	/* calculate X position */						y_value = colCnt * vspacer;					/* calculate Y position */						z_value = colCnt * zspacer;					/* calculate Z position */						p.setPosition(x_value, y_value);			/* Set plane position */						p.setRotation('z', z_value);				/* Set plane Rotation for Z */						//debug("x:"+ x_value +", y:"+ y_value +", z:"+ z_value);						break;												/* Carousel wall */					case "carousel":												var cntForEachRow = totalThumbnailCount/numOfThumbnailRows;						var carouselWidth = cntForEachRow * thmbSizePadding.width; 							debug("RowCount: "+cntForEachRow+ ", cWidth"+ carouselWidth);						x_value = Math.cos(colCnt * anglePer) * carouselWidth;						z_value = Math.sin(x * anglePer) * carouselWidth;						y_value = rowCnt * thmbSizePadding.height;						p.setRotation('rotationY', (-x*anglePer) * (180/Math.PI) + 90);						p.setPosition(x_value, y_value);						break;										}								scene.addChild(p.plane);			}						preloaderOp = "complete";			var timenow:Date = new Date();			debug("BuildWall Complete: "+ ((timenow.getTime() - startTimer.getTime()) / 1000 ) % 60);		}					/*			* Set function to render 3d scene			*/		function startRender(event:Event):void {			camRender();		}					/*			*  Repeating function that is responsible for moving the wall based on 			*/		function camRender():void {						switch(wallType){										case "flat":										cameraTarget.x += ((wallLocationX - cameraTarget.x)/2) / 0.5;					cameraWithSlerp.x += ((wallLocationX - cameraWithSlerp.x)/4) / 0.5;					if(currWallObj != null){						cameraTarget.y += (wallLocationY - cameraTarget.y);						cameraWithSlerp.y += (wallLocationY - cameraWithSlerp.y);					} else {						cameraWithSlerp.y += ((wallLocationY - cameraWithSlerp.y)/4) / 0.5;						cameraTarget.y += (wallLocationY - cameraTarget.y);					}					cameraTarget.z += (wallLocationZ - cameraTarget.z);					cameraWithSlerp.z += ((cameraTarget.z - 400) - cameraWithSlerp.z);					//cameraWithSlerp.zoom = 100;					break;									case "vertical-flat":										var cameraarea = wallLength + 10;					if(cameraTarget.y <= cameraarea){						cameraTarget.y = cameraTarget.y+((wallLocationY - cameraTarget.y)/20) / 0.5;						//debug('move:'+((wallLocationY - cameraTarget.y)/20) / 0.5);						cameraTarget.z = cameraTarget.y+((wallLocationY - cameraTarget.y)/5) / 0.5;						//debug("CameraTarget x: "+ cameraTarget.x);						cameraWithSlerp.y = cameraTarget.y+((wallLocationY - cameraWithSlerp.y)/20) / 0.5;						cameraWithSlerp.z = cameraTarget.y+((wallLocationY - cameraWithSlerp.y)/5) / 0.5;						//cameraWithSlerp.zoom = 100;						//_zoom;					}					break;									default:										break;			}							/*  Render the 3D scene */			renderer.renderScene(scene, cameraWithSlerp, viewport);		}						//this.stage.addEventListener(Event.MOUSE_LEAVE, mouseLeave);		//this.stage.addEventListener(MouseEvent.MOUSE_OUT, mouse_up);										/*			*  Handler for mouse_down event to move wall			* 				*	 @param MouseEvent handler			*/		function moveWallStart(e:MouseEvent):void{			if(currWallObj == null) {				wallMoveInterval.stop();//clearInterval(wallMoveInterval);				/* Clear any existing wall movement */				moveStartPoint = {x:this.stage.mouseX, y:this.stage.mouseY};			/* Get coords of initial mouse click to calculate the distance to move wall */				wallMoveInterval.addEventListener(TimerEvent.TIMER, moveWallListener);  /* Start Moving wall with looping function */				wallMoveInterval.start();				e.updateAfterEvent();								/* smoothing wall movement independant of framerate */			}		}					/**			* 	Looping function to move wall location			*/		function moveWallListener(){			moveCurrPoint = {x:this.stage.mouseX, y:this.stage.mouseY};	/* Set start point of wall movement */			wallLocationX += calcMove(wallLocationX, wallLength, moveStartPoint.x, moveCurrPoint.x);			wallLocationY += calcPivot(wallLocationY, wallHeight/2, moveStartPoint.y, moveCurrPoint.y);		}					/**			* Handler for mouse_leave event for wall			*/		function mouseLeave(e:Event):void{			moveWallStop();		/* Call function to stop moving wall */		}					/**			* Handler for Mouse_up event for wall			*/		function mouse_up(e:MouseEvent):void{			moveWallStop();		/* Call function to stop moving wall */		}					/**			* Stop the wall from moving  			*/		function moveWallStop(){			wallMoveInterval.stop();//clearInterval(wallMoveInterval);		}					/**			*	Calculate moving wall 			*			*	@param currWallLocation			*		Provide the current location of the wall 			* @param wallEndLoc			*		provide the end location of the wall			* @param moveStart			*		Start point of distance to move wall			* @param moveEnd			*		End point of distance to move wall			* 			* return			*/		function calcMove(currWallLocation:Number, wallEndLoc:Number, moveStart:Number, moveEnd:Number) {			var output:Number = 0;	//Set default output to 0				//Make sure start and end move are not empty			if(!moveStart  || !moveEnd) {				return output;			}			var dist = calcDistance(moveStart, moveEnd);	//change output to be distance the mouse is moved							//change output if current wall location is not at start or end of wall			if((currWallLocation >= 0) && (currWallLocation <= wallEndLoc)){				if(((currWallLocation+dist) >= 0) && ((currWallLocation+dist) <= wallEndLoc)) {					output = dist;				}			}							return output;				}					/**			*	Calculate pivot wall move			*			*	@param currWallLocation			*		Provide the current location of the wall 			* @param PivotRange			*		provide the end location of the wall			* @param moveStart			*		Start point of distance to move wall			* @param moveEnd			*		End point of distance to move wall			* 			* return			*/		function calcPivot(currWallLocation:Number, pivotRange:Number, moveStart:Number, moveEnd:Number) {			var output:Number = 0;	//Set default output to 0				//Make sure start and end move are not empty			if(!moveStart  || !moveEnd) {				return output;			}			var dist = calcDistance(moveStart, moveEnd);	//change output to be distance the mouse is moved				//change output if current wall location is not at start or end of wall			if((currWallLocation >= (-pivotRange)) && (currWallLocation <= pivotRange)){				if(((currWallLocation+dist) >= (-pivotRange)) && ((currWallLocation+dist) <= pivotRange)) {					output = dist;				}			}							return output;				}							/**			*	Calculate distance between two points			*			*	@param pointA			*		start point of equation			* @param pointB			*		end point of equation			* 			* return difference between pointA and pointB			*/		function calcDistance(pointA:Number, pointB:Number) {			return pointA-pointB;		}					/**			* Zoom the camera to the plane specified			* 			* @param displayObject3d			*	The 3D object of the image on the wall			*/		function zoomTo(displayObject3d:Object = null):void {								/* Reference: http://www.madvertices.com/2008/10/tweener-bezier-curve-animations.html */			CurveModifiers.init();	/* instantiate the CurveModifiers */							/* Set moveObject at coords of wall location */			var moveObject:Object = {};				moveObject.x = wallLocationX;				moveObject.y = wallLocationY;				moveObject.z = wallLocationZ;							var tweenTo:Object = {};							/* If displayObject3d is null, then just zoom out to zero */			if(displayObject3d == null) {						currWallObj = null; 					/* set current plane to nothing */				_imageLoader.unload();					/* Removes any external files loaded with imageLoader */				removeChild(p_dict["hires-container"]);				tweenTo.x = moveObject.x;				tweenTo.y = 0;				tweenTo.z = 0;								/* If currWallObj is same as last one selected, then zoom out, else zoom in	*/			} else if(currWallObj == displayObject3d.name){				currWallObj = null; 					/* set current plane to nothing */				_imageLoader.unload();					/* Removes any external files loaded with imageLoader */				tweenTo.x = moveObject.x;				tweenTo.y = 0;				tweenTo.z = 0;								/* Else */			} else {				if(_imageLoader){					_imageLoader.unload();				/* Removes any external files loaded with imageLoader */				}				currWallObj = displayObject3d.name; 	/* set current plane to be one just clicked	*/				tweenTo.x = displayObject3d._plane.x;				tweenTo.y = displayObject3d._plane.y;				tweenTo.z = displayObject3d._plane.z+300;				tweenTo.onComplete = zoomIn;				tweenTo.onCompleteParams = new Array(displayObject3d);			}						var myBezierCurvePath:Array	= new Array();					myBezierCurvePath.push({ x: 100,  y: 0 });					//myBezierCurvePath.push({ x: 400, y: 500 });						//tweenTo._bezier = myBezierCurvePath;//new Array({x:0, y:500, z:0});			tweenTo.time = 1;//distance(moveObject,tweenObject)/100;			tweenTo.transition = "easeOut";			tweenTo.onUpdate =  zoomUpdate;			tweenTo.onUpdateParams = new Array(moveObject);			Tweener.addTween(moveObject, tweenTo);						}					/**			*  function to update wall location variables; used by tween to update movement of wall by camRender()			*/		function zoomUpdate(trg:Object):void {			wallLocationX = trg.x;			wallLocationY = trg.y;			wallLocationZ = trg.z;		}					/**			*  			*/		function zoomIn(trg:Object = null):void {							//Create new MovieClip to load image into			var mc:MovieClip = new MovieClip();				mc.name = "hires-container";	//Add name to MC container				mc.alpha = 0;				addChildAt(mc, getChildIndex(viewport));	//Add MC container to stage and set z-index to be on top						p_dict[mc.name] = mc;	//Add MC container to plane array for later access								//Add event listener to MC container for Zooming out			mc.addEventListener(MouseEvent.CLICK, function(e:MouseEvent){ 				zoomTo();			});						var file = imgHolders[trg.name.slice(8,trg.name.length)].hiRes;	//Get filename from imgHolders Array using number for targets name param			debug(file);							_imageLoader = new Loader();	//Create new loader for external images						_imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event){				keepProportions(_imageLoader.content, 400, 400);				mc.addChild(_imageLoader);	//Add loader to the MC container				centerToStage(mc);	//Center MC container				setChildIndex(mc, getChildIndex(viewport));	//Reset z-index of MC Container to make sure its on top				var alphaTween:Tween = new Tween(mc, "alpha", Strong.easeOut, 0, 100, 1,true);				debug("complete");			});			_imageLoader.load(new URLRequest(file));						}									/**			*  Create background for environment			*/		function setupBackground():void {				/* the background is for the "click outside" events */			var backgroundSprite:Sprite = new Sprite();			backgroundSprite.graphics.beginFill(0xFFFFFF);			backgroundSprite.graphics.drawRect(0, 0, this.stage.stageWidth, this.stage.stageHeight);			backgroundSprite.graphics.endFill();			addChildAt(backgroundSprite, 0);			backgroundSprite.addEventListener(MouseEvent.CLICK, backgroundSprite_clickHandler); /* Set event listner for mouse click */			backgroundSprite.addEventListener(MouseEvent.MOUSE_DOWN, moveWallStart);			/* Set event listner for mouse down */			backgroundSprite.addEventListener(MouseEvent.MOUSE_UP, mouse_up);					/* Set event listner for mouse up */		}							/**			*  			*/		function backgroundSprite_clickHandler(e:MouseEvent):void{			debug("Background CLick");			if(currWallObj != null){				zoomTo();			}		}							/**			*  Setup movie to use custom mouse cursor			*/		function useCustomMouse() {						Mouse.hide();			myCursor = new myMouseCursor();			addChild(myCursor);			this.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			this.stage.addEventListener(Event.MOUSE_LEAVE, mouseLeaveHandler);			myCursor.visible = false;			myCursor.mouseEnabled = false;			myCursor.mouseChildren = false;					}					/**			*	Mouse handler for custom cursor			*/		function mouseMoveHandler(e:MouseEvent):void {				/* whenever the mouse moves, place the cursor in the same spot */			if(!mouseOverThumb) {				if (!myCursor.visible) { 					myCursor.visible = true;					Mouse.hide();				}				myCursor.x = e.stageX;				myCursor.y = e.stageY;			}			e.updateAfterEvent();		}					/**			*  Handler to hide the mouse completely			*/		function mouseLeaveHandler(evt:Event):void {				myCursor.visible = false;		}					/**			* Hide custom mouse cursor and display original			*/		function hideCustomMouse() {			myCursor.visible = false;			Mouse.show();		}																	/**			*  Listener to resize stage 			*/		function resizeListener (e:Event):void {			//debug("stageWidth: " + this.stage.stageWidth + " this.stageHeight: " + stage.stageHeight);			//debug("wallWidth:"+ myWall.width +", Wall Height:"+ myWall.height);						resizeMe();		}							/**			* The resizing function			*			* @mc = the movieClip to resize			* @maxW = either the size of the box to resize to, or just the maximum desired width			* @maxH = if desired resize area is not a square, the maximum desired height. default is to match to maxW (so if you want to resize to 200x200, just send 200 once)			*/		function keepProportions(mc:Object, maxW:Number, maxH:Number=0):void{			maxH = maxH == 0 ? maxW : maxH;			mc.width = maxW;			mc.height = maxH;			mc.scaleX < mc.scaleY ? mc.scaleY = mc.scaleX : mc.scaleX = mc.scaleY;		}							/**			*  Center object to stage			* 			*  @mc - Object to be centered			*/		function centerToStage(mc:Object){			mc.x = (this.stage.stageWidth/2) - (mc.width/2);			mc.y = (this.stage.stageHeight/2) - (mc.height/2);		}											/**			*  Resize stage components			*/		function resizeMe():void{								//Scale aspect ratio according to max height of 500				/*thmbWall.height = Math.max(stage.stageHeight,500);			thmbWall.scaleX = thmbWall.scaleY;			if (thmbWall.width<stage.stageWidth) {				thmbWall.width = stage.stageWidth;				thmbWall.scaleY = thmbWall.scaleX;			}*/								//Scale aspect ratio according to max width of 800				/*thmbWall.width = Math.max(stage.stageWidth,800);			thmbWall.scaleY = myWall.scaleX;			if (thmbWall.height<stage.stageHeight) {				thmbWall.height = stage.stageHeight;				thmbWall.scaleX = myWall.scaleY;			}*/								preloader.x = this.stage.stageWidth/2;				preloader.y = this.stage.stageHeight/2;								//Stretches to widescreen				/*var objSlope:Number = myWall.height / myWall.width;			var screenSlope:Number = stage.stageHeight/stage.stageWidth;						if (objSlope > screenSlope ) {  //span vertically, will have filler on the sides				myWall.height = stage.stageHeight;				myWall.width /= myWall.height / stage.stageHeight;					} else if ( objSlope < screenSlope ) {   // span horizontally, filler on top and/or bottom				myWall.height /= myWall.width / stage.stageWidth;				myWall.width = stage.stageWidth			} else {   // same aspect ratio				myWall.width = stage.stageWidth;				myWall.height = stage.stageWidth;			}			*/				//Adjust control mc on stage				/*if(stage.stageWidth <= 980) {				cntrls.x = stage.stageWidth;				cntrls.y = 0;			} else {				var stgoverflow:Number = (stage.stageWidth-980)/2;				cntrls.x = stgoverflow+980;				cntrls.y = 0;			}*/						}									/**			*	Output messsages to flash and firebug consule			*			*	@param mystr			*		string to pass to console			*/		function debug(mystr){			if(debugEnabled){				ExternalInterface.call( "console.log" , mystr);				trace(mystr);			}		}							/*			*	Calculate distance between two points			*			*	@param pointa			*		Array containing (X,Y) of start point			* @param pointb			*		Array containing (X,Y) of end point			* 			* return distance number			*/		function distance(pointa:Object,pointb:Object) {			var a = pointb.x-pointa.x;			var b = pointb.y-pointa.y;			var dist = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2));			return dist;		}				/* End Class */	}			/* End package  */}	